hackerrank java 1d array (part2)

문제이해

시작위치 : 0

시작위치(현재위치)에서 움직일 수 있는 경우의 수
1. 현재 위치 + (-1)
2. 현재 위치 + (1)
3. 현재 위치 + (leap)

승리 조건. canWin -> true -> YES
1. 현재위치에서 +leap 만큼 이동했을 때(도착지), game배열 밖인 경우	|
2. 현재위치에서 +1 만큼 이동했을 때(도착지), game배열 밖인 경우		|
---------------------------------------------------------------------> 도착지가 game배열 밖인 경우 

도착지의 유효 조건
1. 도착지가 game배열 안에 있을 경우
	ㄴ> 승리 조건 1 을 제외하면, 도착지의 위치(인덱스)는 0이상
2. 도착지의 요소이 0일 경우

알고리즘

canWin 메서드가 실행시

1. 시작위치(첫 실행 이후 현재 위치) 0에서 3가지 행동을 할 수 있다. -1, 1, leap 만큼 움직일 수 있다.

2. 시작위치(첫 실행 이후 현재 위치)에서 모든 예상 도착지를 아래의 조건에 의해 판단한다.
2-1. 승리 조건
2-2. 도착지의 유효 조건

3. 위의 조건에 부합된다면 아래의 행동을 취하고 아니라면 4로 넘어간다.
3-1. 승리 조건을 만족한다면 canWin의 리턴값으로 true를 반환 // canWin() -> true -> YES
3-2. 도착지가 유효 하다면, 다시 1번으로 돌아간다.

4. 승리 조건/ 도착지의 유효 조건에 해당하지 않는 경우 예상 도착지는 소멸한다.

5. 위의 1,2,3,4 를 모든 경우의 수를 탐색할 때까지 반복한다.

6. 모든 경우의 수를 탐색했음에도 불구하고 승리조건을 만족시키지 못하면, canWin의 리턴값으로 false를 반환한다.

주의!
이미 방문한 위치(인덱스)는 다시 방문하지 않도록한다
	ㄴ> 방문한 위치에서 이미 경우의 수를 모두 따져봤기때문에 방문할 필요가 없다.
팁!
가장 빠르게 탈출할 수 있는 방법!
leap가 가장 빠르고 leap -> 1 -> -1 순이다.


시작 위치 : int startIdx

현재 위치 : int standingIdx

움직일 수 있는 경우의 수 : int[] caseOfMove = {-1, 1, leap}

예상 도착지; = 현재 위치 + 경우의 수
destination = standingIdx + caseOfMove[0/1/2]

예상 도착지의 요소
game[destination]

승리 조건.
도착지가 game배열 밖일 경우
// destination >= game.length

도착지의 유효 조건
1. 도착지가 game배열 안에 있을 경우 // 0 < destination 
2. 예상 도착지의 요소가 0일 경우 // game[destination] == 0
